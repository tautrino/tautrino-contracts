pragma solidity 0.6.6;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";

interface IPriceProvider {
    function providerName() external view returns (string memory);
    function update() external;
    function lastPrice() external view returns (uint32);
    function updateRequred() external view returns (bool);
}

contract PriceManager is Ownable {

    using SafeMath for uint;

    struct Price {
        string provider; // ex. CoinGecko, CoinMarketCap, ...
        uint64 timestamp;
        uint32 price;
        uint32 x;
    }

    address public tautrino;

    IPriceProvider[] public providers;
    Price[] public lastPrices;

    uint32 public lastAvgPrice;
    uint32[] public primeNumbers = [23, 41, 59, 67, 73, 89, 97]; // prime numbers to get random number

    /**
     * @dev Constructor.
     * @param _tautrino Tautrino contract address.
     */

    constructor(address _tautrino) public Ownable() {
        tautrino = _tautrino;
    }

    /**
     * @dev Update tautrino.
     * @param _tautrino The address of tautrino.
     */

    function setTautrino(address _tautrino) external onlyOwner {
        tautrino = _tautrino;
    }

    /**
     * @dev Add new price provider.
     * @param _provider The address of new provider.
     */

    function addProvider(address _provider) external onlyOwner {
        IPriceProvider _newProvider = IPriceProvider(_provider);
        if (_newProvider.updateRequred()) {
            _newProvider.update();
        }
        providers.push(_newProvider);
    }

    /**
     * @dev Remove existing price provider.
     * @param index Index of provider to remove.
     */

    function removeProvider(uint index) external onlyOwner {
        require(index < providers.length, "index out of bounds");

        if (index < providers.length - 1) {
            providers[index] = providers[providers.length - 1];
        }

        providers.pop();
    }

    /**
     * @dev Calculate average price by the following formular.
     * (price1 * x1 + price2 * x2 + price3 * x3 + ...) / (x1 + x2 + x3 + ...)
     * price1, price2, price3, ... will be fetched from price providers.
     * x1, x2, x3, ... will be generated by current timestamp and prime numbers.
     *
     * @return Calculated average price.
     */

    function averagePrice() external returns (uint32) {
        require(msg.sender == tautrino, "tautrino!");
        require(providers.length > 0, "No providers");

        delete lastPrices;
        uint _priceSum = 0;
        uint _xSum = 0;

        for (uint i = 0; i < providers.length; i++) {
            if (providers[i].updateRequred()) {
                providers[i].update();
            }
            uint32 _price = providers[i].lastPrice();
            uint _x = uint(keccak256(abi.encodePacked(_price, block.coinbase, block.timestamp, block.difficulty, blockhash(block.number)))).mod(uint(primeNumbers[i])).add(1);

            lastPrices.push(Price({
                provider: providers[i].providerName(),
                timestamp: uint64(block.timestamp),
                price: _price,
                x: uint32(_x)
            }));
            _priceSum = _priceSum.add(uint(_price).mul(_x));
            _xSum = _xSum.add(_x);
        }

        require(_priceSum > 0, "Price is not updated yet");

        lastAvgPrice = uint32(_priceSum.div(_xSum));
        return lastAvgPrice;
    }

    /**
     * @dev Add new prime number.
     * @param _primeNumber New prime number to add.
     */

    function addPrimeNumber(uint32 _primeNumber) external onlyOwner {
        primeNumbers.push(_primeNumber);
    }

    /**
     * @dev Remove existing prime number.
     * @param index Index to remove.
     */

    function removePrimeNumber(uint index) external onlyOwner {
        require(index < primeNumbers.length, "index out of bounds");

        if (index < primeNumbers.length - 1) {
            primeNumbers[index] = primeNumbers[primeNumbers.length - 1];
        }

        primeNumbers.pop();
    }

    /**
     * @return Number of providers in providers list.
     */

    function providerSize() external view returns (uint) {
        return providers.length;
    }

    /**
     * @return Number of prices fetched.
     */

    function lastPricesSize() external view returns (uint) {
        return lastPrices.length;
    }
}
