pragma solidity ^0.6.8;

interface IPriceProvider {
    function providerName() external view returns (string memory);
    function fetchPrice() external;
    function lastPrice() external view returns (uint32);
    function lastUpdatedTime() external view returns (uint64);
    function isProvable() external view returns (bool);
    function withdraw() external;
}

interface ITautrino {
    function lastRebaseEpoch() external view returns (uint64);
}

contract PriceManager {

    struct Price {
        string provider; // ex. CoinGecko, CoinMarketCap, ...
        uint64 timestamp;
        uint32 price;
        uint32 x;
    }

    address public governance;
    address public tautrino;

    IPriceProvider[] public providers;
    Price[] public lastPrices;

    uint64 private fetchStartTime = 1;
    uint32 public lastAvgPrice;
    uint32[] public primeNumbers = [23, 41, 59, 67, 73, 89, 97]; // prime numbers to get random number

    /**
     * @dev Constructor.
     * @param _tautrino Tautrino contract address.
     */

    constructor(address _tautrino) public {
        governance = msg.sender;
        tautrino = _tautrino;
    }

    /**
     * @dev Set governance.
     * @param _governance The address of new governance.
     */

    function setGovernance(address _governance) external {
        require(msg.sender == governance, "governance!");
        governance = _governance;
    }

    /**
     * @dev Update tautrino.
     * @param _tautrino The address of tautrino.
     */

    function setTautrino(address _tautrino) external {
        require(msg.sender == governance, "governance!");
        tautrino = _tautrino;
    }

    /**
     * @dev Add new price provider.
     * @param _provider The address of new provider.
     */

    function addProvider(address _provider) external {
        require(msg.sender == governance, "governance!");
        providers.push(IPriceProvider(_provider));
    }

    /**
     * @dev Remove existing price provider.
     * @param index Index of provider to remove.
     */

    function removeProvider(uint index) external {
        require(msg.sender == governance, "governance!");
        require(index < providers.length, "index out of bounds");

        providers[index].withdraw();

        if (index < providers.length - 1) {
            providers[index] = providers[providers.length - 1];
        }

        providers.pop();
    }

    /**
     * @dev Fetch prices from each price providers.
     */

    function updatePrice() external {
        require(msg.sender == tautrino, "tautrino!");
        require(providers.length > 0, "No providers");

        fetchStartTime = uint64(block.timestamp);

        for (uint i = 0; i < providers.length; i++) {
            if (providers[i].isProvable()) {
                providers[i].fetchPrice();
            }
        }
    }

    /**
     * @dev Pay fee for fetching price.
     */

    function payProvableFee(uint _amount) external {
        bool fromProvider = false;
        for (uint i = 0; i < providers.length; i++) {
            if (msg.sender == address(providers[i])) {
                fromProvider = true;
                break;
            }
        }

        require(fromProvider == true, "provider!");
        payable(msg.sender).transfer(_amount);
    }

    /**
     * @dev Calculate average price by the following formular.
     * (price1 * x1 + price2 * x2 + price3 * x3 + ...) / (x1 + x2 + x3 + ...)
     * price1, price2, price3, ... will be fetched from price providers.
     * x1, x2, x3, ... will be generated by current timestamp and prime numbers.
     *
     * @return Calculated average price.
     */

    function averagePrice() external returns (uint32) {
        require(msg.sender == tautrino, "tautrino!");
        require(providers.length > 0, "No providers");

        uint64 _fetchStartTime = fetchStartTime; // gas savings

        delete lastPrices;
        uint32 _priceSum = 0;
        uint32 _xSum = 0;

        for (uint i = 0; i < providers.length; i++) {
            uint64 _lastUpdatedTime = providers[i].lastUpdatedTime();
            if (_lastUpdatedTime >= _fetchStartTime) { // check if updated correctly
                uint32 _x = uint32(uint(keccak256(abi.encodePacked(block.coinbase, block.timestamp, block.difficulty, blockhash(block.number)))) % uint(primeNumbers[i])) + 1;

                uint32 _price = providers[i].lastPrice();
                lastPrices.push(Price({
                    provider: providers[i].providerName(),
                    timestamp: _lastUpdatedTime,
                    price: _price,
                    x: _x
                }));
                _priceSum += _price * _x;
                _xSum += _x;
            }
        }

        require(_priceSum > 0, "Price is not updated yet");

        lastAvgPrice = _priceSum / _xSum;
        return lastAvgPrice;
    }

    /**
     * @dev Add new prime number.
     * @param _primeNumber New prime number to add.
     */

    function addPrimeNumber(uint32 _primeNumber) external {
        require(msg.sender == governance, "governance!");
        primeNumbers.push(_primeNumber);
    }

    /**
     * @dev Remove existing prime number.
     * @param index Index to remove.
     */

    function removePrimeNumber(uint index) external {
        require(msg.sender == governance, "governance!");
        require(index < primeNumbers.length, "index out of bounds");

        if (index < primeNumbers.length - 1) {
            primeNumbers[index] = primeNumbers[primeNumbers.length - 1];
        }

        primeNumbers.pop();
    }

    /**
     * @return Number of providers in providers list.
     */

    function providerSize() external view returns (uint) {
        return providers.length;
    }

    /**
     * @return Number of prices fetched.
     */

    function lastPricesSize() external view returns (uint) {
        return lastPrices.length;
    }

    /**
     * @dev Withdraw all eth balance. Used to migrate to another price manager.
     * @param _receiver Withdraw address.
     */

    function withdrawAll(address payable _receiver) external {
        require(msg.sender == governance, "governance!");

        for (uint i = 0; i < providers.length; i++) {
            providers[i].withdraw();
        }

        _receiver.transfer(address(this).balance);
    }

    /**
     * @dev Receive Ether function.
     */

    receive() external payable {
    }
}
